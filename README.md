# Head First Design Patterns

《Head First Design Patterns》 학습 저장소입니다.

## Strategy Pattern
> 객체의 행동 양식을 캡슐화하고, 이를 객체의 부속품으로 만들어서 동적으로 행동 양식을 변경할 수 있게 하는 패턴.

- 상속이 아닌 구성(Composition) 또는 집합(Aggregation)을 활용
- 인터페이스에 맞춰 프로그래밍하여 구현체를 유연하게 변경 가능
- 실행 시간(Runtime)에 객체의 행동을 변경할 수 있어 유연성 제공

## Observer Pattern
> 객체들 사이의 일대다 의존 관계를 정의하여, 어떤 객체의 상태가 변경되면 모든 의존하는 객체들에게 통지되고 자동으로 업데이트 되도록 하는 패턴.

- 발행/구독 모델을 활용하여 느슨한 결합을 유지
- 상태 변화에 따른 자동 업데이트 기능 제공
- 다양한 관찰자에게 변화를 효율적으로 통지

## Decorator Pattern
> 데코레이터를 사용해 객체에 추가적인 책임을 동적으로 첨가하는 패턴

- 구성(Composition)을 활용하여 기존 객체에 새로운 기능 추가
- 실행 시간(Runtime)에 객체의 기능을 확장할 수 있는 유연성 제공
- 오픈/클로즈 원칙(Open/Closed Principle)을 따름

## Factory Method Pattern
> 객체 생성 처리를 서브클래스로 분리하여, 객체 생성의 인터페이스를 정의하는 패턴.

- 객체 생성 로직과 클라이언트 코드의 분리를 통해 코드의 유연성과 재사용성 향상
- 서브클래스는 어떤 클래스의 인스턴스를 생성할지 결정
- 객체 생성에 필요한 인터페이스를 제공하여, 서브클래스가 실제 생성 로직을 구현
  
## Singleton Pattern
> 클래스의 인스턴스가 오직 하나만 생성되고, 그 인스턴스에 대한 전역 접근을 제공하는 패턴.

- 전역 변수를 사용하지 않고 인스턴스 접근을 제어
- 애플리케이션 전반에 걸쳐 하나의 인스턴스만 유지되어야 할 때 사용
- 생성된 인스턴스는 전체 시스템에서 공유됨

## Command Pattern
> 요청을 객체의 형태로 캡슐화하여 사용자가 다양한 요청, 큐 요청 또는 로그 요청을 매개변수로 할당하고, 실행 취소할 수 있도록 하는 패턴.

- 명령을 발행하는 객체와 명령을 실행하는 객체 사이의 결합도를 낮춤
- 명령을 클래스로 캡슐화함으로써 확장성과 재사용성 향상
- 명령 실행, 실행 취소, 로깅 및 트랜잭션 시스템 구현을 용이하게 함

## Adapter Pattern
> 클래스의 인터페이스를 사용자가 기대하는 다른 인터페이스로 변환하는 패턴. 

- 인터페이스 호환성 문제 없이 서로 다른 클래스들을 연결 사용 가능
- 기존 코드를 변경하지 않고 새로운 인터페이스를 구현할 수 있음
- 레거시 코드와 새로운 시스템 간의 통합을 용이하게 함

## Facade Pattern
> 복잡한 시스템에 대한 간단한 인터페이스를 제공하는 패턴. 

- 복잡한 서브시스템에 대한 단순화된 접근 방법 제공
- 클라이언트와 내부 시스템 간의 의존성 감소
- 시스템의 복잡성 관리와 사용자 친화적인 인터페이스 제공

## Template Method Pattern
> 알고리즘의 구조를 메소드에 정의하고, 일부 단계를 서브클래스에서 구현할 수 있도록 하는 패턴. 

- 알고리즘의 골격을 정의하며, 구체적인 단계는 서브클래스에서 구현
- 코드 재사용과 확장성 향상
- 공통의 알고리즘을 한 곳에서 관리하며 변경에 유연하게 대응

## Iterator Pattern
> 컬렉션의 구현 방법에 상관없이 그 요소들을 순차적으로 접근할 수 있는 방법을 제공하는 패턴

- 컬렉션의 내부 표현 방식을 노출시키지 않고 요소에 접근 가능
- 다양한 컬렉션 구조에 대해 일관된 접근 방법 제공
- 컬렉션 인터페이스와 반복자 인터페이스의 분리로, 다양성과 유연성 향상

## Composite Pattern
> 객체들을 트리 구조로 구성하여 부분-전체 계층을 표현하는 패턴. 

- 복잡한 트리 구조를 단순한 방식으로 처리 가능
- 개별 객체와 구성된 객체 그룹을 클라이언트가 동일하게 다룰 수 있음
- 객체의 추가 및 제거가 용이하여 동적인 구조 변경을 지원

## State Pattern
> 객체의 상태에 따라 객체의 행동을 변경하는 패턴. 

- 상태에 따른 행동 변화를 상태 객체로 캡슐화하여 구현
- 객체의 상태 추가나 변경이 용이함
- 상태 변화에 따른 복잡한 조건문의 사용을 줄일 수 있음

## Proxy Pattern
> 어떤 다른 객체에 대한 접근을 제어하기 위한 대리인 역할을 하는 객체를 제공하는 패턴.

- 원격 객체, 비용이 많이 드는 객체, 보안이 필요한 객체 등의 접근 제어
- 지연 초기화, 로깅, 모니터링, 보안 등 다양한 용도로 활용 가능
- 클라이언트는 프록시를 통해 대상 객체와 상호작용하여, 접근 제어 및 추가 기능 구현
